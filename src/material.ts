export const material = {
  docker: {
    name: 'Linux containers and Kubernetes',
    description: `Kubernetes doesn't know how to deploy Java, Node.js, or .NET applications. The only thing it can deal with is Linux containers. But how do these Linux containers work? Why should you care? Are those necessary to master Kubernetes?`,
    topics: {
      containersVMs: 'Containers vs VMs',
      isolation: 'Understanding process isolation',
      docker: 'Is Docker the only one?',
      run: 'Running containers',
      registries: 'Using Docker registries',
      volumes: 'Mounting volumes',
      build: 'Building Docker images',
      port: 'Exposing ports',
      managing: 'Managing containers lifecycle',
      environment: 'Injecting environment variables',
      debugging: 'Debugging running containers',
    },
  },
  zeroToKubernetes: {
    name: 'Zero to k8s',
    description: 'Learn the basics of Kubernetes and deploy your first application to minikube — a Kubernetes cluster for local development. Learn how to declare resources in YAML files, how to send those to the cluster and retrieve them. Understand how Kubernetes reconciles the desired state of the infrastructure.',
    topics: {
      containersAtScale: 'Managing containers at scale',
      containerOrchestrators: 'The battle of container orchestrators',
      datacentreAsVM: 'Visualising the data centre as a single VM',
      tetrisPlayer: 'The best Tetris player',
      apiInfrastructure: 'Exploring an API over your infrastructure',
      basics: 'What are Pods, Services, and Igresses?',
      localCluster: 'Creating a local cluster with minikube',
      deploy: 'Creating a Deployment',
      expose: 'Exposing Deployments',
      pod: 'What is a Pod?',
      scale: 'Scaling applications',
      failover: 'Testing failover',
    },
  },
  deploymentStrategies: {
    name: 'Deployment strategies',
    description: `Every time you deploy new features in production you don't want to stop your service, load a new version and remove the holding page. Ideally, you should be able to transition to a new version of your application without anyone noticing any downtime. You can leverage Kubernetes to do that.`,
    topics: {
      uptime: 'Monitoring for uptime',
      livenessProbe: 'Liveness probe',
      readinessProbe: 'Readiness probe',
      rollingUpdates: 'Executing zero downtime deployments',
      servicesAndSelectors: 'Using labels and selectors',
      canaryDeployments: 'Releasing features with canary deploymentss',
      bluGreenDeployments: 'Releasing features with blue-green deployments',
      rollbacks: 'Preparing for rollbacks',
    },
  },
  architecture: {
    name: 'Kubernetes Architecture',
    description: `When you deploy applications to Kubernetes you don't decide in which server a container is scheduled. Kubernetes abstracts your data centre into a single entity, and you don't get to worry about the underlying resources. But how does Kubernetes work its magic?`,
    topics: {
      clusters: 'Single and multi-node clusters',
      controlPlane: 'Examining the control plane',
      etcd: 'Persisting changes in etcd',
      raft: 'Syncing changes with RAFT',
      events: 'Event-based architecture',
      kubelet: 'Understanding the kubelet',
      noSinglePointOfFailure: 'Verifying "no single point of failure"',
      multiNodes: 'Setting up a multi-master cluster',
      eks: 'Investigating multi-master setup in EKS',
      monzo: 'Exploring multi-master setup in Monzo',
      kubeadm: 'Creating a 3 node cluster with kubeadm',
      overlay: 'Installing an overlay network',
      ingress: 'Installing an Ingress controller',
      api: 'Exploring the API without kubectl',
      resiliency: 'Taking down the cluster one node at the time',
    },
  },
  networking: {
    name: 'Netwoking in Kubernetes',
    description: `How do you route traffic from the internet to your applications? How can you secure your communication with TLS? How about path routing to different services? In this module, you will explore how the traffic is routed in the cluster.`,
    topics: {
      basicNetworking: 'Network routing in Linux',
      networkRequirements: 'Understanding network requirements',
      endpoints: 'Exploring the Endpoints',
      loadBalancing: 'Balancing in-cluster traffic',
      kubeProxy: 'Routing traffic with kube-proxy',
      interfaces: 'CRI, CNI, CSI: interfaces for the kubelet',
      services: 'Routing traffic to services with kube-proxy',
      latency: 'Choosing between latency and load balancing',
      servicesProsAndCons: 'Pros and cons of the 4 types of Services',
      serviceDiscovery: 'Discovering Services',
      ingress: 'Routing traffic with an Ingress controller',
      e2e: 'End-to-end traffic journey',
      tampering: 'Tampering routing tables',
      debug: 'Debugging an Ingress controller',
    },
  },
  managingState: {
    name: 'Managing state in Kubernetes',
    description: `How does Kubernetes store files and state? Can you host databases in it? Should you? Can you extract configurations and share them with different deployments? How do you make sure that your storage layer is replicated and persisted even if a node becomes unavailable?`,
    topics: {
      configMaps: 'Managing configurations',
      secrets: 'Managing secrets',
      volumes: 'Using Kubernetes Volumes',
      persistentVolumes: 'Creating Persistent Volumes',
      persistentVolumeClaims: 'Creating Persistent Volume Claims',
      storageClass: 'Provisioning volumes dynamically',
      statefulSets: 'Managing stateful applications',
      localVolumes: 'Creating volumes on bare metal',
      singleDatabase: 'Deploying a single database with persitence',
      clusteredDatabase: 'Deploying a clustered database with persitence',
      distributedStorage: 'Designing storage that can span multiple nodes',
    },
  },
  templating: {
    name: 'Templating Kubernetes resources',
    description: `Resources in Kubernetes are described as YAML files. If you wish to have the same resources for different environments such as development, preproduction and production you may be tempted to copy the files three times. Or you could use a templating engine. Learn how to do precisely that with Helm — the Kubernetes package manager.`,
    topics: {
      reusableTemplates: 'Creating reusable templates',
      helm: `Helm's templating engine`,
      helmArchitecture: 'Understanding the Helm architecture',
      templating: 'Templating resources with Go and Sprig',
      releases: 'Managing releases with Helm',
      helpers: 'Writing helper functions',
      environments: 'Managing releases for different environments',
      rollbacks: 'Reverting changes with rollbacks',
      dependencies: 'Depending on other charts',
      repositories: 'Storing reusable templates in repositories',
    },
  },
  advancedNetworking: {
    name: 'Advanced networking',
    description: 'Dive into the specifics of network interfaces, IP addresses and network topologies in this session about advanced Kubernetes networking.',
    topics: {},
  },
  security: {
    name: 'Security',
    description: 'Wear your black hat and try to break the cluster. Study mitigation and countermeasure to secure your cluster against malicious attacks.',
    topics: {},
  },
  autoscaling: {
    name: 'Autoscaling',
    description: ``,
    topics: {},
  },
  advancedScheduling: {
    name: 'Advanced scheduling',
    description: 'Master advanced placements of workloads in your infrastructure. Learn how to schedule machine learning deployments to nodes with GPU or how you can segregate workloads for regions (useful if you need to comply with policies and regulations).',
    topics: {},
  },
  multiCloud: {
    name: 'Multi-cloud, multi-data centre deployments',
    description: `Learn how to design clusters that span multiple cloud providers for resilience, disaster recovery or just saving money.`,
    topics: {},
  },
  serviceMeshes: {
    name: 'Service meshes',
    description: ``,
    topics: {},
  },
  extensions: {
    name: 'Extending and customising Kubernetes',
    description: ``,
    topics: {},
  },
  managedServices: {
    name: 'EKS, AKS, GKE',
    description: 'Discover the nitty-gritty details of how AKS, EKS and GKE work and their strength and limitations.',
    topics: {},
  },
  pipelines: {
    name: 'CI/CD pipelines',
    description: 'Learn how to design CI/CD pipelines that leverage containers and Kubernetes. Ship software quicker, more reliably and cheaply.',
    topics: {},
  },
}